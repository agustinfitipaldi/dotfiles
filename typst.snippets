global !p
def math():
	return vim.eval('typst#in_math()') == '1'

def comment():
	return vim.eval('typst#in_comment()') == '1'

def markup():
	return vim.eval('typst#in_markup()') == '1'

def code():
	return vim.eval('typst#in_code()') == '1'
endglobal


snippet mk "Inline math" A
$$1$$0
endsnippet

snippet dm "Display math" A
$ $1 $$0
endsnippet

context "math()"
snippet llim "Inline limit" iA
limits(lim)_($1->$2) $0
endsnippet

context "math()"
snippet lim "Display limit" A
lim_($1->$2) $0
endsnippet

context "math()"
snippet '\{([A-Za-z])n' "series" wrA
`!p snip.rv = "{" + match.group(1) + "_n}"`
endsnippet

context "math()"
snippet '\{f([a-z])' "function series" wrA
`!p snip.rv = "{f("+match.group(1)+"_n)}"` $0
endsnippet

context "math()"
snippet iff "iff math" A
<==>
endsnippet

snippet iff "iff text" A
$<==>$ $0
endsnippet

context "math()"
snippet '[a-z]::' "function" rA
${1:f}:${2:D}->${3:RR}$0
endsnippet

snippet nbhd "neighborhood" A
neighborhood
endsnippet

snippet ml "multiline math" A
$
$1
$
$0
endsnippet

context "math()"
snippet tt "text mode" A
"$1" $0
endsnippet

context "math()"
snippet ee "epsilon" iA
epsilon
endsnippet

context "math()"
snippet dd "delta" iA
delta
endsnippet

snippet acm "accumulation" A
accumulation
endsnippet

context "math()"
snippet sum "sum" A
sum_(n=${1:1})^(${2:infinity}) ${3}
endsnippet

context "math()"
snippet OO "emptyset" A
emptyset
endsnippet
