# context recognition
global !p
def math():
	return vim.eval('typst#in_math()') == '1'

def comment():
	return vim.eval('typst#in_comment()') == '1'

def markup():
	return vim.eval('typst#in_markup()') == '1'

def code():
	return vim.eval('typst#in_code()') == '1'
endglobal

# modes
snippet mk "Inline math" A
$$1$$0
endsnippet

snippet dm "Display math" A
$ $1 $$0
endsnippet

snippet ml "multiline math" A
$
$1
$
$0
endsnippet

context "math()"
snippet tt "text mode" iA
"$1" $0
endsnippet

# functions, operators, series
context "math()"
snippet llim "Inline limit" iA
limits(lim)_($1->$2) $0
endsnippet

context "math()"
snippet sum "sum" A
sum_(n=${1:1})^(${2:infinity}) ${3}
endsnippet

context "math()"
snippet lim "Display limit" A
lim_($1->$2) $0
endsnippet

context "math()"
snippet '\{([A-Za-z])n' "series" wrA
`!p snip.rv = "{" + match.group(1) + "_n}"`
endsnippet

context "math()"
snippet fxx "function series" wA
{f(x_n)}
endsnippet

context "math()"
snippet '([a-z])nn' "element" wrA
`!p snip.rv = match.group(1)+"_n"`
endsnippet

context "math()"
snippet '[a-z]::' "function" rA
${1:f}:${2:D}->${3:RR}$0
endsnippet

# symbols
context "math()"
snippet iff "iff math" A
<==>
endsnippet

snippet iff "iff text" A
$<==>$ $0
endsnippet

context "math()"
snippet -- "arrow" iA
-->
endsnippet

context "math()"
snippet \\ "without" iA
 without 
endsnippet

context "math()"
snippet OO "emptyset" A
emptyset
endsnippet

# text
snippet nbhd "neighborhood" A
neighborhood
endsnippet

snippet acm "accumulation" A
accumulation
endsnippet

# greek
context "math()"
snippet aa "alpha" iA
alpha
endsnippet

context "math()"
snippet bb "beta" iA
beta
endsnippet

context "math()"
snippet dd "delta" iA
delta
endsnippet

context "math()"
snippet ee "epsilon" iA
epsilon
endsnippet
